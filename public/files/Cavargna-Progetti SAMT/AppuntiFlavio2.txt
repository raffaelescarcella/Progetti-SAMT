----- CRUD API con Repository pattern e DTO. -----


1) Creare nuova blank solution.
2) Inserirci 2 progetti:
	-I°: 		
		Tipo:		Class Library
		Nome:		[Nome]DA
	
	-II°: 	 
		Tipo:		ASP.NET Web Application
		Nome:		[Nome]API
		Template:	ASP.NET 4.5.X Templates -> Empty
		Altro:		Chekcare Web API 

3) Nella prima soluzione ([Nome]DA) eliminare Class1.cs ed aggiungere:
	-I°:
		La cartella "Model", "Repository" e "Service"

	-II° (item):
		Tipo:		ADO.NET Entity Data Model
		Nome:		[Nome]Context
		Contents:	Empty Code First Model

4) Creare la struttura del Database tramite le classi nella cartella model:

	-I°:
		Tipo:		Classe abstract ( public abstract class ModelBase {...} )
		Nome:		ModelBase
		Prop:		
			public int Id { get; set; }

	-II° (Tutte le classi che compongono il database):
		Tipo:		Classe che implementa ModelBase ( public class [Nome] : ModelBase {...} )
		Notazione:	[Table("[Nome]")]

		Esempio (Una persona ha molti hobby 1-N):

		- Person class:

			[Table("Person")]
		    public class Person : ModelBase
		    {
		        public String Name { get; set; }
		        public ICollection<Hobby> Hobbys { get; set; }
		    }
		
		- Hobby class:

			[Table("Hobby")]
		    public class Hobby : ModelBase
		    {
		        public String Type { get; set; }
		        public virtual Person Person { get; set; }
		    }

5) Concluso questo passo, per generare il Database (mdf):

	I°:
		Aprire il file Hobby.DB -> App.config -> nel penultimo TAG <connectionStrings> modificare il tag <add> nell'attributo connectionString="..." ed aggiungere la path in cui si vuole generare il file .mdf tramite:
		(ATTENZIONE WEBCONFIG NON APP)
		Esempio:
			connectionString="attachDBFilename=C:\temp\[Nome].mdf;..."

	II°:
		-Aprire il Package Manager Console (Se non é presente sotto: View -> Other Windows -> Package Manager Console).
		-Eseguire il comando Enable-Migrations 
		-Nel file che si é aperto ([Nome]DA -> Configuration.cs) modificare l'attributo AutomaticMigrationsEnabled e settarlo a true.
		-Tornare nella console e fare un Update-Database, a questo punto nella path specificata nel punto I° apparirà il file .mdf .

6) Importare il database:
	-In Tools -> Connect to Database -> Settare il Server name (LocalDb)\MSSQLLocalDB ed in seguito checkare Attach a database file, e selezionare il file .mdf generato nel punto 5).

7) Generare tabelle con dei record:
	
	I° (Linkare le tabelle):
		Aprire il file [Nome]Context ed aggiungere nella classe le due proprietà contenenti le classi nella cartella model.

		Esempio:

        public virtual DbSet<Hobby> Hobbys { get; set; }
        public virtual DbSet<Person> People { get; set; }

    II° (Aggiungere dei record) opzionale:
    	Aprire il file Configuration.cs e nel metodo Seed aggiungere degli oggetti che rispecchino lo schema del DB.

    	Esempio:

    	Hobby h1 = new Hobby() 
    	{
            Type = "Flettere"
        };

        Hobby h2 = new Hobby()
        {
            Type = "Donne"
        };

        Person p = new Person()
        {
            Name = "Flavio",
            Hobbys = new List<Hobby> { h1, h2 }
        };

        context.Hobbys.Add(h1);
        context.Hobbys.Add(h2);
        context.People.Add(p);

    III°: 
    	Effettuare nel Package Manager Console un: Update-Database per rigenerare il DB con i suoi record.


8) Creazione delle Repository (oggetti che permettono di effettuare le operazioni sul database (get, insert, update, delete)):
	
	I°:
		Creare il prototipo della repository, nella cartella Repository creare un'interfaccia (IRepository) come segue:

			public interface IRepository<T> where T : ModelBase
		    {
		        List<T> Get(); 		//ritorna lista di oggetti
		        T Get(int id); 		//ritorna l'oggetto a partire dall'id
		        T Insert(T obj); 	//inserisce un oggetto
		        T Update(T obj); 	//aggiorna un oggetto
		        int Delete(T obj); 	//cancella un oggetto
		    }

	II°:
		Creare una classe abstract Repository (sempre nella cartella Repository) che implementi l'interfaccia IRepository, come segue:
			(Questa classe permette di avere una classe generica di tutte le classi della cartella model, di modo che si possano effettuare le operazioni Get,Insert,Update,Delete di tutti gli oggetti nel DB).

			ATTENZIONE: se fai copia-incolla cambia il '[nome]' con il nome corrispondente

			public abstract class Repository<T> : IRepository<T> where T : ModelBase
		    {
		        private [Nome]Context context;
		        public Repository([Nome]Context ctx)
		        {
		            context = ctx;
		        }

		        public virtual int Delete(T obj)
		        {
		            //int id = context.Set<T>().Find(obj).id;
		            context.Set<T>().Remove(obj);
		            return context.SaveChanges();
		        }

		        public virtual List<T> Get()
		        {
		            return context.Set<T>().ToList();
		        }

		        public virtual T Get(int id)
		        {
		            return context.Set<T>().Find(id);
		        }

		        public virtual T Insert(T obj)
		        {
		            context.Set<T>().Add(obj);
		            return obj;
		        }

		        public virtual T Update(T obj)
		        {
		            //non si può usare Set perchè non accedo allo state
		            context.Entry(obj).State = System.Data.Entity.EntityState.Modified;
		            context.SaveChanges();
		            return obj;
		        }
		    }



	III°:
		Per ogni classe della cartella Model creare una classe [Nome]Repository che implementi la classe Repository, come segue:

			public class [Nome]Repository : Repository<[Nome]>
		    {
		        public [Nome]Repository([Nome]Context ctx) : base(ctx)
		        {

		        }
		    }

9) Creazione del servizio che comunicherà poi con la seconda soluzione (API).
	
	I°:
		Creare il prototipo del servizio, quindi nella cartella Service creare l'interfaccia I[Nome]Service, come segue.
		Essa dovrà contenere tutte le repository create(per avere accesso alla gestione di tutte le classi di DB),
		quelli che sono già inseriti sono gli esempi di come dovrà essere:

		public interface I[Nome]Service
	    {	    	
	        Repository<Person> People { get; }
	        Repository<Hobby> Hobbys { get; }
	    }

	II°:
		Creare il servizio vero e proprio quindi creare una classe, sempre nella cartella Service, chiamata [Nome]Service,
		che estenda I[Nome]Service, come segue.
		Questo é un esempio, anche qui dovranno essere creati tutti i getter di tutte le repository presenti:


		public class HobbyService : IHobbyService
	    {
	        private Repository<Person> people;
	        private Repository<Hobby> hobbys;        

	        Repository<Person> IHobbyService.People
	        {
	            get
	            {
	                if (people == null)
	                {
	                    people = new PersonRepository(new HobbyContext());
	                }

	                return people;
	            }
	        }

	        Repository<Hobby> IHobbyService.Hobbys
	        {
	            get
	            {
	                if (hobbys == null)
	                {
	                    hobbys = new HobbyRepository(new HobbyContext());
	                }

	                return hobbys;
	            }
	        }
	    }


10) Creazione dei DTO (Data Transfer Object) che saranno poi ricevuti/mandati tramite HTTP.

	I°:
		Nel progetto [Nome]API nella cartella Models creare gli oggetti DTO, essi dovranno essere pensati di modo che si possano creare degli oggetti normali (non DTO) con delle relazioni, un esempio:

		La classe Person é struttrata come segue:

			public class Person : ModelBase
		    {
		        public String Name { get; set; }
		        public ICollection<Hobby> Hobbys { get; set; }
		    }

		se si volesse aggiungere una persona con un hobby si dovrebbe passare il nome dell'hobby e il numero (Id) della persona, quindi il DTO corrispondente dell'hobby sarebbe:

			public class HobbyDTO
		    {
		    	[Required]
		        public int PersonId { get; set; }
		        [Required]
		        public String Hobby { get; set; }
		    }

	    ...mentre quello per aggiungere una persona:

	    	public class PersonDTO
		    {
		    	[Required]
		        public String Name { get; set; }
		    }

		...a tutti gli attributi non obbligatori va rimossa la notazione [Required]

11) Creazione delle factory che trasformeranno i DTO in classi inseribili nel database e viceversa.

	I°:
		Aggiungere la referenza alla classe [Nome]DA nel progetto [Nome]API.

	II°:
		Creare un'interfaccia IModelFactory con i prototipi dei metodi di conversione DTO<->Classe ordinaria.

		Esempio:

			public interface IModelFactory
		    {
		        HobbyDTO Create(Hobby hobby);
		        PersonDTO Create(Person person);
		        Hobby Create(HobbyDTO hobbyDTO);
		        Person Create(PersonDTO personDTO);
		    }

	III°:
		Creare una classe ModelFactory che implementa IModelFactory e trasforma gli oggetti in DTO e viceversa.
		Esempio:

		public Hobby Create(HobbyDTO hobbyDTO)
        {
            return new Hobby()
            {
                Type = hobbyDTO.Hobby
            };            
        }

        public Person Create(PersonDTO personDTO)
        {
            return new Person()
            {
                Name = personDTO.Name
            };
        }

        public PersonDTO Create(Person person)
        {
            return new PersonDTO()
            {
                Name = person.Name
            };                
        }

        public HobbyDTO Create(Hobby hobby)
        {
            return new HobbyDTO()
            {
                Hobby = hobby.Type
            };
        }


